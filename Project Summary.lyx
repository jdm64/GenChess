#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
GenChess Project Summary
\end_layout

\begin_layout Author
Justin Madru (jdm64@csu.fullerton.edu)
\end_layout

\begin_layout Section*
Introduction
\end_layout

\begin_layout Standard
For my project I've created a simple chess variant playing program.
 The specific chess variant is called Genesis Chess, which is a chess variant
 that I created.
 There are two programs, or parts, of my project.
 The first is the back-end chess engine which is a full implementation of
 the game using a text based terminal interface.
 Also included is a simple front end GUI that is controlled by the back
 end.
\end_layout

\begin_layout Section*
Design
\end_layout

\begin_layout Subsubsection*
Game Rules
\end_layout

\begin_layout Standard
Being a chess variant, many of the rules are the same as traditional chess.
 Except where explicitly stated the rules are the same as chess, but the
 following changes have been made:
\end_layout

\begin_layout Itemize
The game begins with a blank board; henceforth there is no initial piece
 configuration.
\end_layout

\begin_layout Itemize
On a player's first turn they must place their king down.
 Any square is valid so long as neither king is in check.
\end_layout

\begin_layout Itemize
Pieces that haven't yet been placed are called Reserve pieces.
 Captured pieces are not added to a player's Reserve pieces and are therefore
 not playable.
\end_layout

\begin_layout Itemize
Pawns move one space in any direction, with the limitation that captures
 can only happen diagonally (like a bishop) and movements without capture
 only happen horizontal or vertically (like a rook).
\end_layout

\begin_layout Itemize
Special moves including: pawn promotion, castling, and en passant, have
 been removed as they have no meaning with the game starting with no initial
 configuration.
\end_layout

\begin_layout Standard
Once this initial king placement phase is over, the game proceeds like chess.
 Players continue to make one move per turn.
 There are two types of moves:
\end_layout

\begin_layout Itemize
A traditional move is where a piece on the board is moved from one location
 to another within the movement limitations of that piece.
 This includes captures and checking of the opponent's king.
\end_layout

\begin_layout Itemize
A placement move is where a player selects one of their Reserve pieces,
 and places it on the board.
 A player cannot check their opponent's king by a placement move under any
 circumstance.
 A player can attack other pieces or evade being checked by the opponent
 by placing a piece.
\end_layout

\begin_layout Standard
Like regular chess the game continues until one of three game states is
 achieved:
\end_layout

\begin_layout Itemize
One player has checkmated his opponent.
 A checkmate is when a player has no legal moves and is in check.
\end_layout

\begin_layout Itemize
A stalemate, where it's a player's turn and they have no legal moves, but
 they are not in check.
\end_layout

\begin_layout Itemize
Draw by insufficient material.
 This happens where neither side could achieve a checkmate.
\end_layout

\begin_layout Subsubsection*
Required Skill & Game Time
\end_layout

\begin_layout Standard
The necessary prerequisite skill is an understanding of the rules and strategies
 of traditional chess.
 While the strategies in Genesis Chess are different than traditional chess,
 a player capable of understanding and playing chess should be able to play
 my game.
 Also like regular chess, the average game time ranges between 30 minutes
 to an hour or more.
 This is highly dependent on the difference in skill of the players.
\end_layout

\begin_layout Subsubsection*
Game Interface & Representation
\end_layout

\begin_layout Standard
Like previously stated, there are two interfaces developed for this project.
 The first is the terminal based interface.
 Once the program starts, the user is presented with a board and prompt.
 The board shows the rank and file information for square coordinates along
 with representations for pieces on the board.
 Pieces on the board use the algebraic chess notation for piece identification,
 except that black pieces have and asterisk following the letter.
 Henceforth, pieces are denoted by a single capital letter, where K=king,
 Q=Queen, R=Rook, B=Bishop, N=Knight, P=Pawn.
 Similarly, squares are denoted using the same algebraic notation, rank
 then file in lower case.
 For example: a1 would be lower left and h8 would be upper right corner.
\end_layout

\begin_layout Standard
At the prompt the user can enter in a move command or a control command.
 Move commands have the following format:
\end_layout

\begin_layout Itemize
[Piece][Square] - the format to place a piece on the board.
 Example: Qd5.
\end_layout

\begin_layout Itemize
[From][To] - is for movement moves where from is the location of the piece
 and to is where the piece should be moved.
 Example: a1a8
\end_layout

\begin_layout Standard
There are a few control commands accepted by the engine:
\end_layout

\begin_layout Itemize
new - starts a new game with the same players.
 If the engine was started with white a human player then 'new' would not
 change this.
\end_layout

\begin_layout Itemize
list - shows the location of all 32 pieces.
\end_layout

\begin_layout Itemize
help - shows the list of control commands.
\end_layout

\begin_layout Itemize
quit - exits the engine, closing the program.
\end_layout

\begin_layout Standard
The second and more intuitive interface is the graphical PyQt based interface.
 In the center is the board's 64 squares as buttons.
 On either side of the board is a column of pieces for placing.
 Messages about game state information, errors and what button has been
 pressed are displayed in the status-bar at the bottom.
 The top contains menu items for modifying program and game states, like
 new game and quiting.
 Instead of entering board coordinates for moving, the appropriate buttons
 are pressed.
\end_layout

\begin_layout Section*
Software Architecture
\end_layout

\begin_layout Subsubsection*
The Main Function
\end_layout

\begin_layout Standard
The main function is simple and consists of two main operations: handling
 program arguments and initializing an instance of the Game class.
 The command line arguments are handled by getopts which sets certain flag
 variables.
 Then the flags are passed to an instance of the Game class's constructor
 which initialize the game's internal data (board and players).
 Finally, game.run() is called to enter the game loop.
 The program terminates when game.run() exits.
\end_layout

\begin_layout Subsubsection*
Interaction Of Major Classes
\end_layout

\begin_layout Standard
The overall design of the chess engine is similar to the client-server model.
 Within the Game class are three other classes.
 First is the Board class that could be classified as the server.
 It contains the game state information and query functions that alter,
 retrieve or print game state data.
 The other classes interact with the 
\begin_inset Quotes eld
\end_inset

server
\begin_inset Quotes erd
\end_inset

, including the Game class that selects what 
\begin_inset Quotes eld
\end_inset

client
\begin_inset Quotes erd
\end_inset

 (ie.
 player) to run or if the game is in an end state like checkmate.
\end_layout

\begin_layout Standard
The other two classes are the player classes (white and black).
 Depending on the games initialization arguments, white and black will be
 initialized as either HumanPlayer or ComputerPlayer classes.
 In either case, these classes are all inherited from the parent Player
 class.
 The common functions that the player classes run are doMove and pieceIndex
 which requests the board to apply a move or to locate a piece respectively.
 The HumanPlayer class uses stdin to receive move requests or control commands
 from the user.
 Similarly, the ComputerPlayer does alpha-beta pruning on a min-max tree
 to determine what move to request from the Board class.
\end_layout

\begin_layout Subsubsection*
Board Game Data
\end_layout

\begin_layout Standard
There are several important structures that are used to store the game state.
 The first and most obvious data item is how the board is represented.
 For my implementation, the board is an array of 64 chars.
 The board's two dimensional nature is maintained by using the same mechanism
 that C++ would use to convert a two dimensional array back down to the
 memory's one dimensional addresses.
 Each char represents information about a square.
 Positive values represent white pieces, negative values are black pieces,
 and zero is used for empty squares.
 The exact values are as follows: pawn=1, knight=2, bishop=3, rook=4, queen=5,
 king=6.
\end_layout

\begin_layout Standard
Because pieces are placed down and can exist outside of the board, I also
 maintain a piece list that contains the piece type and location for all
 32 pieces.
 The ordering of the piece list array (called pieces) is similar to the
 board's arrangement.
 Black pieces are contained in the index range 0-15, while white are in
 16-31.
 Within a color's range of pieces, the eight pawns come first, followed
 by the two knights and so forth until the king.
 For example, black knights are found at index 8 and 9, while white knights
 are at 24 and 25.
\end_layout

\begin_layout Standard
Finally what's a chess game without a method for representing moves.
 Instead of having a different copy of the board for each move state (which
 would wast space), I created a structure that holds the necessary information
 to apply and undo moves.
 In this structure (called Move) stores the index of the piece that is moving
 along with the index of any captured piece so that the move can be undone.
 Also stored is the piece's from and to location movement information.
 Using this struct, the players class can cause a move to happen by calling
 doMove(Move) and the board class will apply a reversible function on the
 board to update the pieces.
\end_layout

\begin_layout Subsubsection*
Move Generation
\end_layout

\begin_layout Standard
The most important part of a chess engine is the move generation.
 The AI must generate large amounts of moves to finally determine the best
 move to make.
 For my move generation I originally used two lookup tables (like found
 in the TSCP engine).
 Using two sets of offsets the move squares could be calculated.
 Unfortunately I was not satisfied by the performance of the move generation.
 Henceforth, decided to precalculate the move lookup for each type of piece
 for each location of the board.
 Moves for a piece can then be generated by setting the location and type
 of piece and iterating over the lookup table.
 All the lookup tables together take up about 4K of memory, but because
 there's only one array, the lookup the performance is improved.
\end_layout

\begin_layout Section*
The A.I.
\end_layout

\begin_layout Standard
The game of chess is a combinatorial game where each player tries to make
 moves that increases the chances of winning while at the same time hindering
 their opponent from obtaining the same goal.
 While human players form strategies and counter strategies, it is hard
 to develop a computer program that is completely strategy based.
 Instead, most game engines use the fact that the game states can be modeled
 as a game tree with each state being assigned a value.
 Then the game is reduced to each player selecting the move that maximizes
 the value in their favor, henceforth minimizes the value of the opponent.
 So, strategy is replaced with calculating as many combinations of moves
 and counter moves by the opponent several moves into the future.
 Then the value of the leaf nodes are calculated and propagate up the tree
 using the 
\begin_inset Quotes eld
\end_inset

tug-of-war
\begin_inset Quotes erd
\end_inset

 calculation where moves done by the computer choose the largest score,
 and moves simulating what the opponent could do will pick the smallest
 value.
\end_layout

\begin_layout Standard
This algorithm is called Minimax, and is based on the fact that the chess
 is a zero-sum situation.
 The definition of zero-sum is a situation in which a participant's gain
 or loss is exactly balanced by the losses or gains of the other participants.
 Therefore, summing the value of each participant would result in zero.
 For example, if white captures a piece then the value of white goes up
 equally as much as black's value goes down.
 Transferring this idea to the game tree, at alternating levels of the tree
 are the different players.
 Odd levels would be the minimizing player (ie.
 the one playing against the computer), while even would be the maximizing
 player.
\end_layout

\begin_layout Standard
The number of moves on each players turn is so many that searching the entire
 tree would be too time consuming and unnecessary because only the top nodes
 are important.
 Therefore people have developed algorithms that still return the correct
 value of the top nodes while not having to search everything.
 This main search optimization is called alpha-beta pruning.
 It uses the previously found maximum and minimum scores to create cut offs.
 The alpha value is the lowest value that the maximizing player is guaranteed
 to obtain, while the beta value is the largest value that the minimizing
 player is guaranteed to obtain.
 Therefore if we find a new alpha that is larger than our current one then
 we can assume that the move that resulted in the larger alpha value will
 be a better move.
 Similarly if we find a beta value that is lower than our current one, the
 previous move wasn't as good as the current one.
 Pruning of the tree can then happen when alpha is larger than beta.
 At this point, it means that alpha's (the maximizer) score is so large
 that beta (minimizer) would have easily prevented alpha from obtaining
 this game state by selecting a different move.
 The result is that it is pointless to search deeper in this part of the
 tree and all subsequent child nodes can be pruned.
\end_layout

\begin_layout Standard
The alpha-beta pruning can be optimized even further and this is the algorithm
 that I use.
 NegaScout is an optimized alpha-beta algorithm that prunes even more nodes
 then traditional alpha-beta.
 The algorithm employs a scout window to the search function.
 At each level a complete search using the current correct alpha-beta values
 is done for the first move.
 Then for the next moves at the same level the alpha-beta window is reduced
 to a width of one.
 This causes cutoffs to happen much more frequently.
 As long as the new score returned is outside the alpha-beta window the
 value can be used.
 But if the value falls within the window a research must be done.
 If the moves are properly ordered then researches happen infrequently.
\end_layout

\begin_layout Standard
Unfortunately, in my testing the strength of play for the computer I needed
 to optimize even further.
 There are three other algorithms that I used to optimize the move selection.
 The first is killer-move which is a move ordering algorithm.
 Moves that cause cutoffs (alpha>beta) are saved and tried first in another
 branch of the game tree of the same level.
 This move ordering will usually case cutoffs to happen within the first
 couple of moves tried.
 The other algorithm that I implemented was Quiescence search.
 This algorithm searches the tree similarly to NegaScout but only searches
 capture or check moves that might cause the evaluation function to return
 the wrong value.
 This is because a search might stop at a capture move and the algorithm
 would assume that this is a good move, but it might not see the next move
 that results in an even greater value piece to be captured.
 Henceforth the quiescence search stops when the game tree becomes quiet.
 Finally I also implemented iterative deepening which searches shallowly
 and the progressively deeper.
 This results in a faster search because the move ordering is continually
 refined.
\end_layout

\begin_layout Section*
Screen Shots
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ScreenShot02.png
	width 6.5in

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ScreenShot01.png
	width 6in

\end_inset


\end_layout

\begin_layout Section*
Bibliography
\end_layout

\begin_layout Standard
Several sources helped my in understanding and implementing my chess engine.
 The first and most important was the Chess Programming Wiki (chessprogramming.wi
kispaces.com).
 The site contain detailed explanations of board representations, move generatio
n, evaluation functions, and tree searches.
 Another helpful resource was the source code of a simple chess engine called
 TSCP (tckerrigan.com/Chess/TSCP).
 For the user interface written in Python and Qt, I used Qt-Designer to
 prototype the interface and the PyQt tools to convert the UI files to python
 code.
 I also frequently referenced the Qt docs for the required API (doc.qt.nokia.com).
 With these resources and the obligatory Google search to solve more specific
 problems, I was able to implement the chess engine and graphical interface.
\end_layout

\end_body
\end_document
